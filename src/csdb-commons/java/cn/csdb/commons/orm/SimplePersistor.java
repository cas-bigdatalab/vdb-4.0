/*
 * Created on 2007-6-5
 */
package cn.csdb.commons.orm;

import java.io.Serializable;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Map.Entry;

import cn.csdb.commons.orm.bean.BeanContext;
import cn.csdb.commons.orm.bean.SessionBean;
import cn.csdb.commons.orm.handler.AfterDelete;
import cn.csdb.commons.orm.handler.AfterInsert;
import cn.csdb.commons.orm.handler.AfterUpdate;
import cn.csdb.commons.orm.handler.BeforeDelete;
import cn.csdb.commons.orm.handler.BeforeInsert;
import cn.csdb.commons.orm.handler.BeforeUpdate;
import cn.csdb.commons.orm.impl.BeanContextImpl;
import cn.csdb.commons.orm.impl.BeanQueryImpl;
import cn.csdb.commons.sql.JdbcManager;
import cn.csdb.commons.sql.JdbcSource;
import cn.csdb.commons.sql.catalog.JdbcTable;
import cn.csdb.commons.sql.jdbc.GeneratedKeyGetter;
import cn.csdb.commons.sql.jdbc.NoColumnsException;
import cn.csdb.commons.sql.jdbc.sql.DeleteSql;
import cn.csdb.commons.sql.jdbc.sql.InsertSql;
import cn.csdb.commons.sql.jdbc.sql.UpdateSql;
import cn.csdb.commons.util.StringKeyMap;

public class SimplePersistor implements Persistor
{
	private OrMapping _mapping;

	private JdbcSource _jdbcSource;

	private JdbcTable _table;

	public SimplePersistor(OrMapping mapping) throws Exception
	{
		_mapping = mapping;
		_jdbcSource = JdbcManager.getInstance().getJdbcSource(
				_mapping.getDataSource());
		_table = _jdbcSource.getJdbcCatalog().getDatabase().getTable(
				_mapping.getTableName());
	}

	public SimplePersistor(BeanMapping mapping) throws Exception
	{
		this(new BeanMappingAdapter(mapping));
	}

	public Query createQuery() throws Exception
	{
		return new BeanQueryImpl(_jdbcSource, this, _mapping);
	}

	public int delete(Object bean) throws Exception
	{
		if (bean instanceof BeforeDelete)
		{
			if (!((BeforeDelete) bean).onBeforeDelete())
				return -1;
		}

		int rows = _jdbcSource.executeUpdate(new DeleteSql(_mapping
				.getTableName(), _mapping.getIdFilter(_mapping
				.getPrimaryKeyValue(bean))));

		if (rows > 0)
		{
			if (bean instanceof AfterDelete)
			{
				((AfterDelete) bean).onAfterDelete();
			}
		}

		return rows;
	}

	public int insert(Object bean) throws Exception
	{
		if (bean instanceof BeforeInsert)
		{
			if (!((BeforeInsert) bean).onBeforeInsert())
				return -1;
		}

		Map columns = new HashMap();
		_mapping.bean2Map(bean, columns, true);

		GeneratedKeyGetter getter = new GeneratedKeyGetter();

		int rows = _jdbcSource.executeUpdate(new InsertSql(_mapping
				.getTableName(), columns), getter);

		if (rows > 0)
		{
			// 自动增长字段
			String agkn = _table.getPrimaryKeyName();
			if (agkn != null)
			{
				String key = getter.getGeneratedKey();
				if (key != null)
				{
					long autoGeneratedKeyValue = Long.parseLong(key);
					if (autoGeneratedKeyValue != -1)
					{
						Long agk = new Long(autoGeneratedKeyValue);
						_mapping.setGeneratedKey(bean, agkn, agk);
						columns.put(agkn, agk);
					}
				}
			}

			updateBeanContext(bean, columns);

			if (bean instanceof AfterInsert)
			{
				((AfterInsert) bean).onAfterInsert();
			}
		}

		return rows;
	}

	private void updateBeanContext(Object o, Map columns)
	{
		if (o instanceof SessionBean)
		{
			SessionBean sb = ((SessionBean) o);
			BeanContext bc = sb.getBeanContext();
			if (bc == null)
			{
				bc = new BeanContextImpl(this, columns);
				sb.setBeanContext(bc);
			}
			else
			{
				bc.getSqlMap().putAll(columns);
			}
		}
	}

	/**
	 * 通过比较，返回所有脏字段
	 */
	private Map getDirtyFields(Object bean) throws Exception
	{
		Map values = new HashMap();
		_mapping.bean2Map(bean, values, false);
		Map dirtyFields = values;

		if (bean instanceof SessionBean)
		{
			SessionBean sb = (SessionBean) bean;
			BeanContext bc = sb.getBeanContext();
			if (bc != null)
			{
				Map original = bc.getSqlMap();
				if (original != null)
				{
					// 比较每个字段的内容是否发生更改
					dirtyFields = new StringKeyMap();
					Iterator it = values.entrySet().iterator();

					while (it.hasNext())
					{
						Entry me = (Entry) it.next();
						Object key = me.getKey();

						// 不处理以.开头的字段，一般这样的字段用以存储运行时信息，而不需要持久化
						if (key instanceof String)
						{
							if (((String) key).startsWith("."))
							{
								continue;
							}
						}

						Object value = me.getValue();

						// 判断对象指针
						if (original.containsKey(key))
						{
							Object ov = original.get(key);

							if (ov == value)
								continue;

							if (ov != null && ov.equals(value))
								continue;
						}

						dirtyFields.put(key, value);
					}
				}
			}
		}

		return dirtyFields;
	}

	public Object lookup(Serializable id) throws Exception
	{
		Query query = new BeanQueryImpl(_jdbcSource, this, _mapping);
		query.setFilter(_mapping.getIdFilter(id));
		return query.single();
	}

	public int update(Object bean) throws Exception
	{
		if (bean instanceof BeforeUpdate)
		{
			if (!((BeforeUpdate) bean).onBeforeUpdate())
				return -1;
		}

		Map columns = getDirtyFields(bean);

		if (columns.size() == 0)
			return 1;

		try
		{
			int rows = _jdbcSource.executeUpdate(new UpdateSql(_mapping
					.getTableName(), columns, _mapping.getIdFilter(_mapping
					.getPrimaryKeyValue(bean))));
			if (rows > 0)
			{
				updateBeanContext(bean, columns);

				if (bean instanceof AfterUpdate)
				{
					((AfterUpdate) bean).onAfterUpdate();
				}
			}

			return rows;
		}
		catch (NoColumnsException e)
		{
			return 1;
		}
	}

	public JdbcSource getJdbcSource()
	{
		return _jdbcSource;
	}
}
